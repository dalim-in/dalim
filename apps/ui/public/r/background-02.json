{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "background-02",
  "type": "registry:component",
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/default/components/background/background-02.tsx",
      "content": "\"use client\"\n\nimport { useCallback, useEffect, useRef, useState } from \"react\"\n\nimport { cn } from \"@/registry/default/lib/utils\"\n\nexport default function Component() {\n  return (\n    <div className=\"h-[650px] w-full\">\n      <RainBackground\n        intensity={500}\n        speed={0.5}\n        angle={10}\n        color={\"rgba(174, 194, 224, 0.6)\"}\n        dropSize={{ min: 1, max: 2 }}\n        lightningEnabled={true}\n        lightningFrequency={8}\n        thunderEnabled={true}\n        thunderVolume={1}\n        thunderDelay={2}\n        className=\"bg-background relative flex h-full w-full flex-col items-center justify-center overflow-hidden rounded-xl border bg-gradient-to-b from-zinc-950 via-zinc-800 to-zinc-950\"\n      >\n        <div className=\"p-6\">\n          <p className=\"z-10 text-white text-center text-3xl font-semibold tracking-tighter whitespace-pre-wrap  md:text-7xl \">\n            Rain\n          </p>\n        </div>\n      </RainBackground>\n    </div>\n  )\n}\n\ninterface RainDrop {\n  id: number\n  left: number\n  animationDuration: number\n  opacity: number\n  size: number\n  delay: number\n}\n\ninterface Lightning {\n  id: number\n  type: \"flash\" | \"bolt\"\n  intensity: number\n  duration: number\n}\n\ninterface RainBackgroundProps {\n  intensity?: number // Number of raindrops (default: 100)\n  speed?: number // Base speed multiplier (default: 1)\n  color?: string // Rain color (default: \"rgba(174, 194, 224, 0.6)\")\n  angle?: number // Wind angle in degrees (default: 0)\n  dropSize?: {\n    min: number\n    max: number\n  } // Drop size range (default: {min: 1, max: 3})\n  // Thunder & Lightning props\n  lightningEnabled?: boolean // Enable lightning effects (default: false)\n  lightningFrequency?: number // Lightning frequency in seconds (default: 8)\n  thunderEnabled?: boolean // Enable thunder sounds (default: false)\n  thunderVolume?: number // Thunder volume 0-1 (default: 0.5)\n  thunderDelay?: number // Delay between lightning and thunder in seconds (default: 2)\n  className?: string\n  children?: React.ReactNode\n}\n\nfunction RainBackground({\n  intensity = 100,\n  speed = 1,\n  color = \"rgba(174, 194, 224, 0.6)\",\n  angle = 0,\n  dropSize = { min: 1, max: 3 },\n  lightningEnabled = false,\n  lightningFrequency = 8,\n  thunderEnabled = false,\n  thunderVolume = 0.5,\n  thunderDelay = 2,\n  className,\n  children,\n}: RainBackgroundProps) {\n  const [raindrops, setRaindrops] = useState<RainDrop[]>([])\n  const [lightning, setLightning] = useState<Lightning | null>(null)\n  const [, setIsFlashing] = useState(false)\n  const thunderAudioRef = useRef<HTMLAudioElement | null>(null)\n  const lightningTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Initialize thunder audio\n  useEffect(() => {\n    if (thunderEnabled && typeof window !== \"undefined\") {\n      thunderAudioRef.current = new Audio()\n      thunderAudioRef.current.volume = thunderVolume\n      // Using a data URL for a simple thunder sound simulation\n      thunderAudioRef.current.src =\n        \"data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT\"\n    }\n  }, [thunderEnabled, thunderVolume])\n\n  // Generate raindrops\n  useEffect(() => {\n    const drops: RainDrop[] = []\n\n    for (let i = 0; i < intensity; i++) {\n      drops.push({\n        id: i,\n        left: Math.random() * 100,\n        animationDuration: (Math.random() * 1 + 0.5) / speed,\n        opacity: Math.random() * 0.6 + 0.2,\n        size: Math.random() * (dropSize.max - dropSize.min) + dropSize.min,\n        delay: Math.random() * 2,\n      })\n    }\n\n    setRaindrops(drops)\n  }, [intensity, speed, dropSize])\n\n  // Lightning effect\n  const triggerLightning = useCallback(() => {\n    if (!lightningEnabled) return\n\n    const lightningTypes: (\"flash\" | \"bolt\")[] = [\"flash\", \"flash\", \"bolt\"] // More flashes than bolts\n    const type =\n      lightningTypes[Math.floor(Math.random() * lightningTypes.length)]\n    const intensity = Math.random() * 0.8 + 0.2 // 0.2 to 1.0\n    const duration =\n      type === \"flash\" ? 150 + Math.random() * 100 : 300 + Math.random() * 200\n\n    const newLightning: Lightning = {\n      id: Date.now(),\n      type,\n      intensity,\n      duration,\n    }\n\n    setLightning(newLightning)\n    setIsFlashing(true)\n\n    // End lightning effect\n    setTimeout(() => {\n      setIsFlashing(false)\n      setLightning(null)\n    }, duration)\n\n    // Play thunder after delay\n    if (thunderEnabled && thunderAudioRef.current) {\n      setTimeout(() => {\n        if (thunderAudioRef.current) {\n          thunderAudioRef.current.currentTime = 0\n          thunderAudioRef.current.play().catch(() => {\n            // Handle autoplay restrictions\n            console.log(\"Thunder audio blocked by browser autoplay policy\")\n          })\n        }\n      }, thunderDelay * 1000)\n    }\n\n    // Schedule next lightning\n    const nextLightning =\n      (lightningFrequency + Math.random() * lightningFrequency) * 1000\n    lightningTimeoutRef.current = setTimeout(triggerLightning, nextLightning)\n  }, [lightningEnabled, lightningFrequency, thunderEnabled, thunderDelay])\n\n  // Start lightning cycle\n  useEffect(() => {\n    if (lightningEnabled) {\n      const initialDelay = Math.random() * lightningFrequency * 1000\n      lightningTimeoutRef.current = setTimeout(triggerLightning, initialDelay)\n    }\n\n    return () => {\n      if (lightningTimeoutRef.current) {\n        clearTimeout(lightningTimeoutRef.current)\n      }\n    }\n  }, [lightningEnabled, triggerLightning])\n\n  // Generate lightning bolt path\n  const generateBoltPath = () => {\n    const startX = Math.random() * 100\n    const segments = 8 + Math.random() * 4\n    let path = `M ${startX} 0`\n    let currentX = startX\n    let currentY = 0\n\n    for (let i = 1; i <= segments; i++) {\n      const segmentHeight = 100 / segments\n      currentY = i * segmentHeight\n      currentX += (Math.random() - 0.5) * 20 // Random horizontal deviation\n      currentX = Math.max(0, Math.min(100, currentX)) // Keep within bounds\n      path += ` L ${currentX} ${currentY}`\n    }\n\n    return path\n  }\n\n  return (\n    <div className={cn(\"relative overflow-hidden\", className)}>\n      {/* Lightning Effects */}\n      {lightning && (\n        <>\n          {/* Screen Flash */}\n          {lightning.type === \"flash\" && (\n            <div\n              className=\"animate-lightning-flash pointer-events-none absolute inset-0 z-20\"\n              style={{\n                background: `radial-gradient(circle, rgba(255, 255, 255, ${lightning.intensity}) 0%, rgba(135, 206, 235, ${lightning.intensity * 0.3}) 50%, transparent 100%)`,\n                animationDuration: `${lightning.duration}ms`,\n              }}\n            />\n          )}\n\n          {/* Lightning Bolt */}\n          {lightning.type === \"bolt\" && (\n            <div className=\"pointer-events-none absolute inset-0 z-20\">\n              <svg\n                className=\"animate-lightning-bolt h-full w-full\"\n                style={{ animationDuration: `${lightning.duration}ms` }}\n              >\n                <defs>\n                  <filter id=\"glow\">\n                    <feGaussianBlur stdDeviation=\"3\" result=\"coloredBlur\" />\n                    <feMerge>\n                      <feMergeNode in=\"coloredBlur\" />\n                      <feMergeNode in=\"SourceGraphic\" />\n                    </feMerge>\n                  </filter>\n                </defs>\n                <path\n                  d={generateBoltPath()}\n                  stroke={`rgba(255, 255, 255, ${lightning.intensity})`}\n                  strokeWidth=\"2\"\n                  fill=\"none\"\n                  filter=\"url(#glow)\"\n                />\n                <path\n                  d={generateBoltPath()}\n                  stroke={`rgba(135, 206, 235, ${lightning.intensity * 0.8})`}\n                  strokeWidth=\"1\"\n                  fill=\"none\"\n                />\n              </svg>\n            </div>\n          )}\n        </>\n      )}\n\n      {/* Rain container */}\n      <div\n        className=\"pointer-events-none absolute inset-0\"\n        style={{\n          transform: `rotate(${angle}deg)`,\n          transformOrigin: \"center center\",\n        }}\n      >\n        {raindrops.map((drop) => (\n          <div\n            key={drop.id}\n            className=\"animate-rain-fall absolute\"\n            style={{\n              left: `${drop.left}%`,\n              width: `${drop.size}px`,\n              height: `${drop.size * 10}px`,\n              background: `linear-gradient(to bottom, transparent, ${color})`,\n              borderRadius: `${drop.size}px`,\n              animationDuration: `${drop.animationDuration}s`,\n              animationDelay: `${drop.delay}s`,\n              opacity: drop.opacity,\n              top: \"-20px\",\n            }}\n          />\n        ))}\n      </div>\n\n      {/* Content */}\n      <div className=\"relative z-10\">{children}</div>\n\n      <style jsx>{`\n        @keyframes rain-fall {\n          0% {\n            transform: translateY(-20px);\n          }\n          100% {\n            transform: translateY(calc(100vh + 20px));\n          }\n        }\n\n        @keyframes lightning-flash {\n          0% {\n            opacity: 0;\n          }\n          10% {\n            opacity: 1;\n          }\n          20% {\n            opacity: 0.3;\n          }\n          30% {\n            opacity: 1;\n          }\n          40% {\n            opacity: 0;\n          }\n          100% {\n            opacity: 0;\n          }\n        }\n\n        @keyframes lightning-bolt {\n          0% {\n            opacity: 0;\n          }\n          10% {\n            opacity: 1;\n          }\n          20% {\n            opacity: 0.7;\n          }\n          30% {\n            opacity: 1;\n          }\n          40% {\n            opacity: 0.4;\n          }\n          50% {\n            opacity: 0.8;\n          }\n          60% {\n            opacity: 0;\n          }\n          100% {\n            opacity: 0;\n          }\n        }\n\n        .animate-rain-fall {\n          animation: rain-fall linear infinite;\n        }\n\n        .animate-lightning-flash {\n          animation: lightning-flash ease-out forwards;\n        }\n\n        .animate-lightning-bolt {\n          animation: lightning-bolt ease-out forwards;\n        }\n      `}</style>\n    </div>\n  )\n}\n\ninterface ThunderAudioProps {\n  volume: number\n  onPlay?: () => void\n}\n\nexport function ThunderAudio({ volume, onPlay }: ThunderAudioProps) {\n  const audioContextRef = useRef<AudioContext | null>(null)\n\n  useEffect(() => {\n    if (typeof window !== \"undefined\") {\n      audioContextRef.current = new (window.AudioContext ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (window as any).webkitAudioContext)()\n    }\n  }, [])\n\n  const generateThunderSound = async () => {\n    if (!audioContextRef.current) return\n\n    const audioContext = audioContextRef.current\n    const duration = 2 + Math.random() * 3 // 2-5 seconds\n    const sampleRate = audioContext.sampleRate\n    const frameCount = sampleRate * duration\n    const arrayBuffer = audioContext.createBuffer(1, frameCount, sampleRate)\n    const channelData = arrayBuffer.getChannelData(0)\n\n    // Generate thunder-like noise\n    for (let i = 0; i < frameCount; i++) {\n      const t = i / sampleRate\n      let sample = 0\n\n      // Multiple layers of noise for realistic thunder\n      sample += (Math.random() * 2 - 1) * Math.exp(-t * 2) * 0.5 // Initial crack\n      sample += (Math.random() * 2 - 1) * Math.exp(-t * 0.5) * 0.3 // Rumble\n      sample += Math.sin(t * 60 + Math.random() * 10) * Math.exp(-t * 1) * 0.2 // Low frequency\n\n      // Apply envelope for natural fade\n      const envelope = Math.exp(-t * 0.8) * (1 - Math.exp(-t * 10))\n      channelData[i] = sample * envelope * volume\n    }\n\n    // Play the generated sound\n    const source = audioContext.createBufferSource()\n    const gainNode = audioContext.createGain()\n\n    source.buffer = arrayBuffer\n    source.connect(gainNode)\n    gainNode.connect(audioContext.destination)\n    gainNode.gain.value = volume\n\n    source.start()\n    onPlay?.()\n  }\n\n  return {\n    playThunder: generateThunderSound,\n  }\n}\n",
      "type": "registry:component"
    }
  ],
  "meta": {
    "tags": [
      "background",
      "bg",
      "texture",
      "pattern"
    ],
    "style": 1,
    "colSpan": 3
  }
}