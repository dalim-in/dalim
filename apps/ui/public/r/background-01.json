{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "background-01",
  "type": "registry:component",
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/default/components/background/background-01.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n\"use client\"\n\nimport { useEffect, useRef } from \"react\"\nimport Script from \"next/script\"\n\nexport default function Component() {\n  const containerRef = useRef<HTMLDivElement>(null)\n  const scriptLoaded = useRef(false)\n  const engineRef = useRef<any>(null)\n  const renderRef = useRef<any>(null)\n\n  useEffect(() => {\n    // Only run once the script is loaded and the component is mounted\n    if (scriptLoaded.current && containerRef.current) {\n      initSimulation(containerRef.current)\n    }\n    // Cleanup function\n    return () => {\n      if (engineRef.current && renderRef.current) {\n        const Matter = (window as any).Matter\n        Matter.Render.stop(renderRef.current)\n        Matter.Engine.clear(engineRef.current)\n        // Remove event listeners\n        window.removeEventListener(\"resize\", handleResize)\n      }\n    }\n  }, [])\n\n  const handleScriptLoad = () => {\n    scriptLoaded.current = true\n    if (containerRef.current) {\n      initSimulation(containerRef.current)\n    }\n  }\n\n  // Resize handler function (defined outside to be able to remove it)\n  const handleResize = () => {\n    if (!containerRef.current || !renderRef.current) return\n    const containerWidth = containerRef.current.clientWidth\n    const containerHeight = containerRef.current.clientHeight\n    // Update canvas dimensions\n    renderRef.current.canvas.width = containerWidth\n    renderRef.current.canvas.height = containerHeight\n    renderRef.current.options.width = containerWidth\n    renderRef.current.options.height = containerHeight\n    // Update boundaries\n    updateBoundaries(containerWidth, containerHeight)\n  }\n\n  // Update boundaries function\n  const updateBoundaries = (width: number, height: number) => {\n    if (!engineRef.current) return\n    const Matter = (window as any).Matter\n    const world = engineRef.current.world\n    // Remove old boundaries\n    const bodies = Matter.Composite.allBodies(world)\n    bodies.forEach((body: any) => {\n      if (body.isStatic && body.label !== \"MouseConstraint\") {\n        Matter.World.remove(world, body)\n      }\n    })\n    // Create new boundaries with increased thickness for better containment\n    const thickness = 100 // Aumentado de 50 para 100\n    const ground = Matter.Bodies.rectangle(\n      width / 2,\n      height + thickness / 2,\n      width + thickness * 2,\n      thickness,\n      {\n        isStatic: true,\n        render: { fillStyle: \"transparent\" },\n        label: \"ground\",\n      }\n    )\n    const wallLeft = Matter.Bodies.rectangle(\n      -thickness / 2,\n      height / 2,\n      thickness,\n      height + thickness * 2,\n      {\n        isStatic: true,\n        render: { fillStyle: \"transparent\" },\n        label: \"wallLeft\",\n      }\n    )\n    const wallRight = Matter.Bodies.rectangle(\n      width + thickness / 2,\n      height / 2,\n      thickness,\n      height + thickness * 2,\n      {\n        isStatic: true,\n        render: { fillStyle: \"transparent\" },\n        label: \"wallRight\",\n      }\n    )\n    const roof = Matter.Bodies.rectangle(\n      width / 2,\n      -thickness / 2,\n      width + thickness * 2,\n      thickness,\n      {\n        isStatic: true,\n        render: { fillStyle: \"transparent\" },\n        label: \"roof\",\n      }\n    )\n    Matter.World.add(world, [ground, wallLeft, wallRight, roof])\n  }\n\n  // Simulation initialization\n  function initSimulation(containerElement: HTMLDivElement) {\n    // Garantir que Matter está disponível\n    if (typeof window === \"undefined\" || !(window as any).Matter) return\n    const Matter = (window as any).Matter\n    const Engine = Matter.Engine,\n      Render = Matter.Render,\n      World = Matter.World,\n      Bodies = Matter.Bodies,\n      MouseConstraint = Matter.MouseConstraint,\n      Mouse = Matter.Mouse,\n      Events = Matter.Events\n\n    const engine = Engine.create()\n    const world = engine.world\n    // Ajustar configurações do motor para mais estabilidade\n    engine.world.gravity.y = 0.6 // Reduzido de 0.8 para 0.6 (menos gravidade)\n    engine.constraintIterations = 3 // Aumentar iterações para melhor estabilidade\n    engine.positionIterations = 8 // Aumentar iterações de posição\n    engine.velocityIterations = 6 // Aumentar iterações de velocidade\n\n    // Store engine reference for cleanup\n    engineRef.current = engine\n\n    const containerWidth = containerElement.clientWidth\n    const containerHeight = containerElement.clientHeight\n\n    // Set up Matter.js renderer\n    const render = Render.create({\n      element: containerElement,\n      engine: engine,\n      options: {\n        width: containerWidth,\n        height: containerHeight,\n        background: \"transparent\", // No default background\n        wireframes: false,\n        showBounds: false,\n        showVelocity: false,\n        showAngleIndicator: false,\n        showDebug: false,\n      },\n    })\n\n    // Store render reference for cleanup and resize\n    renderRef.current = render\n\n    // Remove canvas border\n    if (render.canvas) {\n      render.canvas.style.border = \"none\"\n      render.canvas.style.outline = \"none\"\n      render.canvas.style.position = \"absolute\"\n      render.canvas.style.top = \"0\"\n      render.canvas.style.left = \"0\"\n      render.canvas.style.width = \"100%\"\n      render.canvas.style.height = \"100%\"\n    }\n\n    Render.run(render)\n    Engine.run(engine)\n\n    // Create boundaries with increased thickness\n    const thickness = 100 // Aumentado para melhor contenção\n    const ground = Bodies.rectangle(\n      containerWidth / 2,\n      containerHeight + thickness / 2,\n      containerWidth + thickness * 2,\n      thickness,\n      {\n        isStatic: true,\n        render: { fillStyle: \"transparent\" },\n        label: \"ground\",\n      }\n    )\n    const wallLeft = Bodies.rectangle(\n      -thickness / 2,\n      containerHeight / 2,\n      thickness,\n      containerHeight + thickness * 2,\n      {\n        isStatic: true,\n        render: { fillStyle: \"transparent\" },\n        label: \"wallLeft\",\n      }\n    )\n    const wallRight = Bodies.rectangle(\n      containerWidth + thickness / 2,\n      containerHeight / 2,\n      thickness,\n      containerHeight + thickness * 2,\n      {\n        isStatic: true,\n        render: { fillStyle: \"transparent\" },\n        label: \"wallRight\",\n      }\n    )\n    const roof = Bodies.rectangle(\n      containerWidth / 2,\n      -thickness / 2,\n      containerWidth + thickness * 2,\n      thickness,\n      {\n        isStatic: true,\n        render: { fillStyle: \"transparent\" },\n        label: \"roof\",\n      }\n    )\n\n    World.add(world, [ground, wallLeft, wallRight, roof])\n\n    // Sync Matter.js bodies with HTML elements\n    const tags = containerElement.querySelectorAll(\".tag\")\n    const tagBodies = Array.from(tags).map((tag) => {\n      const width = (tag as HTMLElement).offsetWidth\n      const height = (tag as HTMLElement).offsetHeight\n\n      // Position tags based on container size with safe margins\n      const margin = 60 // Margem maior para evitar spawn fora dos limites\n      const x =\n        Math.random() * (containerWidth - width - margin * 2) +\n        width / 2 +\n        margin\n      const y =\n        Math.random() * (containerHeight - height - margin * 2) +\n        height / 2 +\n        margin\n      const body = Bodies.rectangle(x, y, width, height, {\n        chamfer: { radius: height / 2 }, // Rounded corners\n        density: 0.008, // Reduzido de 0.01 para 0.008 (mais leve)\n        friction: 0.3, // Aumentado de 0.1 para 0.3 (mais atrito)\n        frictionAir: 0.02, // Aumentado para mais resistência do ar\n        restitution: 0.4, // Reduzido de 0.8 para 0.4 (menos elástico)\n        render: {\n          fillStyle: \"transparent\", // Disable Matter.js background rendering\n        },\n      })\n      World.add(world, body)\n      return { body, element: tag }\n    })\n\n    // Função para verificar e reposicionar tags que saem dos limites\n    const checkBounds = () => {\n      tagBodies.forEach(({ body }) => {\n        const { x, y } = body.position\n        const margin = 50\n        // Se a tag sair muito dos limites, reposicionar\n        if (\n          x < -margin ||\n          x > containerWidth + margin ||\n          y < -margin ||\n          y > containerHeight + margin\n        ) {\n          // Reposicionar no centro com velocidade zero\n          Matter.Body.setPosition(body, {\n            x: containerWidth / 2 + (Math.random() - 0.5) * 100,\n            y: containerHeight / 4 + Math.random() * 100,\n          })\n          Matter.Body.setVelocity(body, { x: 0, y: 0 })\n          Matter.Body.setAngularVelocity(body, 0)\n        }\n        // Limitar velocidade máxima para evitar movimentos muito bruscos\n        const maxVelocity = 15\n        if (body.velocity.x > maxVelocity)\n          Matter.Body.setVelocity(body, { x: maxVelocity, y: body.velocity.y })\n        if (body.velocity.x < -maxVelocity)\n          Matter.Body.setVelocity(body, { x: -maxVelocity, y: body.velocity.y })\n        if (body.velocity.y > maxVelocity)\n          Matter.Body.setVelocity(body, { x: body.velocity.x, y: maxVelocity })\n        if (body.velocity.y < -maxVelocity)\n          Matter.Body.setVelocity(body, { x: body.velocity.x, y: -maxVelocity })\n        // Limitar velocidade angular\n        const maxAngularVelocity = 0.3\n        if (body.angularVelocity > maxAngularVelocity)\n          Matter.Body.setAngularVelocity(body, maxAngularVelocity)\n        if (body.angularVelocity < -maxAngularVelocity)\n          Matter.Body.setAngularVelocity(body, -maxAngularVelocity)\n      })\n    }\n\n    // Sync positions and rotation with Matter.js\n    Events.on(engine, \"afterUpdate\", () => {\n      checkBounds() // Verificar limites a cada frame\n      tagBodies.forEach(({ body, element }) => {\n        const { x, y } = body.position\n        const angle = body.angle\n        // TypeScript cast\n        const htmlElement = element as HTMLElement\n        // Aplicar apenas transformação, sem sombras dinâmicas\n        htmlElement.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px) rotate(${angle}rad)`\n      })\n    })\n\n    // Add mouse interactivity with limited force\n    const mouse = Mouse.create(render.canvas)\n    const mouseConstraint = MouseConstraint.create(engine, {\n      mouse: mouse,\n      constraint: {\n        stiffness: 0.15, // Reduzido de 0.2 para 0.15 (menos força)\n        render: {\n          visible: false,\n        },\n      },\n    })\n    World.add(world, mouseConstraint)\n\n    // Add resize event listener\n    window.addEventListener(\"resize\", handleResize)\n  }\n\n  return (\n    <>\n      <Script\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\"\n        onLoad={handleScriptLoad}\n        strategy=\"afterInteractive\"\n      />\n      <div className=\"w-full\">\n        <div className=\"rounded-3xl border\">\n          <div className=\" \">\n            <div\n              ref={containerRef}\n              className=\"relative h-[650px] w-full overflow-hidden\"\n            >\n              <div className=\"tag rounded-3xl bg-blue-500 p-3 px-6\">Dalim</div>\n              <div className=\"tag rounded-3xl bg-green-500 p-3 px-6\">\n                Design\n              </div>\n              <div className=\"tag rounded-3xl bg-yellow-500 p-3 px-6\">\n                Graphic\n              </div>\n              <div className=\"tag rounded-3xl bg-red-500 p-3 px-6\">Fonts</div>\n              <div className=\"tag rounded-3xl bg-violet-500 p-3 px-6\">UI</div>\n              <div className=\"tag rounded-3xl bg-lime-500 p-3 px-6\">\n                Components\n              </div>\n              <div className=\"tag rounded-3xl bg-rose-500 p-3 px-6\">Ali</div>\n              <div className=\"tag rounded-3xl bg-purple-500 p-3 px-6\">\n                Icons\n              </div>\n              <div className=\"tag rounded-3xl bg-teal-500 p-3 px-6\">Logos</div>\n              <div className=\"tag rounded-3xl bg-pink-500 p-3 px-6\">\n                Templates\n              </div>\n              <div className=\"tag rounded-3xl bg-stone-500 p-3 px-6\">\n                Mockups\n              </div>\n              <div className=\"tag rounded-3xl bg-amber-500 p-3 px-6\">\n                Assets\n              </div>\n              <div className=\"tag rounded-3xl bg-emerald-500 p-3 px-6\">\n                Creative\n              </div>\n              <div className=\"tag rounded-3xl bg-indigo-500 p-3 px-6\">\n                Blocks\n              </div>\n              <div className=\"tag rounded-3xl bg-fuchsia-500 p-3 px-6\">\n                Colors\n              </div>\n              <div className=\"tag rounded-3xl bg-sky-500 p-3 px-6\">Code</div>\n              <div className=\"tag rounded-3xl bg-cyan-500 p-3 px-6\">\n                Develop\n              </div>\n              <div className=\"tag rounded-3xl bg-orange-500 p-3 px-6\">\n                Website\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <style jsx>{`\n        .tag-canvas {\n          width: 100%;\n          height: 60vh;\n          min-height: 300px;\n          position: relative;\n          overflow: hidden;\n        }\n\n        .tag-canvas::before {\n          content: \"\";\n          position: absolute;\n          top: -20%;\n          left: -10%;\n          width: 40%;\n          height: 120%;\n          transform: rotate(15deg);\n          z-index: 1;\n          pointer-events: none;\n        }\n\n        .tag-canvas::after {\n          content: \"\";\n          position: absolute;\n          top: 0;\n          left: 0;\n          right: 0;\n          height: 30%;\n          z-index: 1;\n          pointer-events: none;\n        }\n\n        .tag {\n          position: absolute;\n          display: inline-flex;\n          justify-content: center;\n          align-items: center;\n          pointer-events: none;\n          transition: all 0.1s ease;\n        }\n      `}</style>\n    </>\n  )\n}\n\n// Adicionar tipos para o Matter.js\ndeclare global {\n  interface Window {\n    Matter: any\n  }\n}\n",
      "type": "registry:component"
    }
  ],
  "meta": {
    "tags": [
      "background",
      "bg",
      "texture",
      "pattern"
    ],
    "style": 1,
    "colSpan": 3
  }
}