{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixel-animation",
  "type": "registry:ui",
  "files": [
    {
      "path": "registry/default/ui/backgrounds/pixel-animation.tsx",
      "content": "\"use client\"\n\nimport { useEffect, useRef } from \"react\"\n\nimport { cn } from \"@/registry/default/lib/utils\"\n\nconst rand = (min: number, max: number) => {\n  return Math.random() * (max - min) + min\n}\n\nclass Pixel {\n  x: number\n  y: number\n  color: string\n  speed: number\n  size: number\n  sizeStep: number\n  minSize: number\n  maxSizeAvailable: number\n  maxSize: number\n  sizeDirection: number\n  delay: number\n  delayHide: number\n  counter: number\n  counterHide: number\n  counterStep: number\n  isHidden: boolean\n  isFlicking: boolean\n\n  constructor(\n    x: number,\n    y: number,\n    color: string,\n    speed: number,\n    delay: number,\n    delayHide: number,\n    step: number,\n    boundSize: number\n  ) {\n    this.x = x\n    this.y = y\n    this.color = color\n    this.speed = rand(0.1, 0.9) * speed\n    this.size = 0\n    this.sizeStep = rand(0, 0.5)\n    this.minSize = 0.5\n    this.maxSizeAvailable = boundSize || 2\n    this.maxSize = rand(this.minSize, this.maxSizeAvailable)\n    this.sizeDirection = 1\n    this.delay = delay\n    this.delayHide = delayHide\n    this.counter = 0\n    this.counterHide = 0\n    this.counterStep = step\n    this.isHidden = false\n    this.isFlicking = false\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const centerOffset = this.maxSizeAvailable * 0.5 - this.size * 0.5\n    ctx.fillStyle = this.color\n    ctx.fillRect(\n      this.x + centerOffset,\n      this.y + centerOffset,\n      this.size,\n      this.size\n    )\n  }\n\n  show() {\n    this.isHidden = false\n    this.counterHide = 0\n\n    if (this.counter <= this.delay) {\n      this.counter += this.counterStep\n      return\n    }\n\n    if (this.size >= this.maxSize) {\n      this.isFlicking = true\n    }\n\n    if (this.isFlicking) {\n      this.flicking()\n    } else {\n      this.size += this.sizeStep\n    }\n  }\n\n  hide() {\n    this.counter = 0\n\n    if (this.counterHide <= this.delayHide) {\n      this.counterHide += this.counterStep\n      if (this.isFlicking) {\n        this.flicking()\n      }\n      return\n    }\n\n    this.isFlicking = false\n\n    if (this.size <= 0) {\n      this.size = 0\n      this.isHidden = true\n      return\n    } else {\n      this.size -= 0.05\n    }\n  }\n\n  flicking() {\n    if (this.size >= this.maxSize) {\n      this.sizeDirection = -1\n    } else if (this.size <= this.minSize) {\n      this.sizeDirection = 1\n    }\n\n    this.size += this.sizeDirection * this.speed\n  }\n}\n\ninterface PixelAnimationProps {\n  containerWidth?: string\n  containerHeight?: string\n  backgroundColor?: string\n  pixelGap?: number\n  animationSpeed?: number\n  colorHueStart?: number\n  colorHueRange?: number\n  maxPixelSize?: number\n  animationDuration?: number\n  showHint?: boolean\n  hintText?: string\n  className?: string\n}\n\nexport function PixelAnimation({\n  containerWidth = \"100vw\",\n  containerHeight = \"100vh\",\n  pixelGap = 6,\n  animationSpeed = 0.25,\n  colorHueStart,\n  colorHueRange = 50,\n  maxPixelSize,\n  animationDuration = 360,\n  className,\n}: PixelAnimationProps = {}) {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const containerRef = useRef<HTMLDivElement>(null)\n  const animationRef = useRef<{\n    pixels: Pixel[]\n    request: number | null\n    lastTime: number\n    ticker: number\n    maxTicker: number\n    animationDirection: number\n    width: number\n    height: number\n  }>({\n    pixels: [],\n    request: null,\n    lastTime: 0,\n    ticker: 0,\n    maxTicker: animationDuration,\n    animationDirection: 1,\n    width: 0,\n    height: 0,\n  })\n\n  const getDelay = (x: number, y: number, direction?: boolean) => {\n    const { width, height } = animationRef.current\n    const dx = x - width * 0.5\n    let dy = y - height\n\n    if (direction) {\n      dy = y\n    }\n\n    return Math.sqrt(dx ** 2 + dy ** 2)\n  }\n\n  const initPixels = () => {\n    const { width, height } = animationRef.current\n    const h = colorHueStart ?? Math.floor(rand(0, 360))\n    const colorsLen = 5\n    const colors = Array.from(\n      { length: colorsLen },\n      (_, index) =>\n        `hsl(${Math.floor(rand(h, h + (index + 1) * (colorHueRange / colorsLen)))} 100% ${rand(50, 100)}%)`\n    )\n\n    const gap = pixelGap\n    const step = (width + height) * 0.005\n    const speed = rand(0.008, animationSpeed)\n    const maxSize = maxPixelSize ?? Math.floor(gap * 0.5)\n\n    animationRef.current.pixels = []\n\n    for (let x = 0; x < width; x += gap) {\n      for (let y = 0; y < height; y += gap) {\n        if (x + maxSize > width || y + maxSize > height) {\n          continue\n        }\n\n        const color = colors[Math.floor(Math.random() * colorsLen)]\n        const delay = getDelay(x, y)\n        const delayHide = getDelay(x, y)\n\n        animationRef.current.pixels.push(\n          new Pixel(x, y, color, speed, delay, delayHide, step, maxSize)\n        )\n      }\n    }\n  }\n\n  const animate = () => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(\"2d\")\n    if (!ctx) return\n\n    const interval = 1000 / 60\n    const animation = animationRef.current\n\n    animation.request = requestAnimationFrame(animate)\n\n    const now = performance.now()\n    const diff = now - (animation.lastTime || 0)\n\n    if (diff < interval) {\n      return\n    }\n\n    animation.lastTime = now - (diff % interval)\n\n    ctx.clearRect(0, 0, animation.width, animation.height)\n\n    if (animation.ticker >= animation.maxTicker) {\n      animation.animationDirection = -1\n    } else if (animation.ticker <= 0) {\n      animation.animationDirection = 1\n    }\n\n    let allHidden = true\n\n    animation.pixels.forEach((pixel) => {\n      if (animation.animationDirection > 0) {\n        pixel.show()\n      } else {\n        pixel.hide()\n        allHidden = allHidden && pixel.isHidden\n      }\n\n      pixel.draw(ctx)\n    })\n\n    animation.ticker += animation.animationDirection\n\n    if (animation.animationDirection < 0 && allHidden) {\n      animation.ticker = 0\n    }\n  }\n\n  const resize = () => {\n    const canvas = canvasRef.current\n    const container = containerRef.current\n    if (!canvas || !container) return\n\n    if (animationRef.current.request) {\n      cancelAnimationFrame(animationRef.current.request)\n    }\n\n    const rect = container.getBoundingClientRect()\n\n    animationRef.current.width = Math.floor(rect.width)\n    animationRef.current.height = Math.floor(rect.height)\n\n    canvas.width = animationRef.current.width\n    canvas.height = animationRef.current.height\n\n    initPixels()\n\n    animationRef.current.ticker = 0\n\n    animate()\n  }\n\n  const handleClick = () => {\n    resize()\n  }\n\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(resize)\n    const container = containerRef.current\n\n    if (container) {\n      resizeObserver.observe(container)\n    }\n\n    return () => {\n      if (animationRef.current.request) {\n        cancelAnimationFrame(animationRef.current.request)\n      }\n      resizeObserver.disconnect()\n    }\n  }, [])\n\n  return (\n    <div\n      className={cn(\"h-full w-full\", className)}\n      style={{\n        overflow: \"hidden\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        cursor: \"pointer\",\n      }}\n      onClick={handleClick}\n    >\n      <div\n        ref={containerRef}\n        style={{\n          width: containerWidth,\n          height: containerHeight,\n        }}\n      >\n        <canvas ref={canvasRef} />\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    }
  ]
}