{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "fluid-dynamics",
  "type": "registry:ui",
  "files": [
    {
      "path": "registry/default/ui/backgrounds/fluid-dynamics.tsx",
      "content": "\"use client\"\n\nimport { useCallback, useEffect, useRef } from \"react\"\n\ninterface FluidDynamicsProps {\n  width?: number\n  height?: number\n  iterations?: number\n  strength?: number\n  radius?: number\n  viscosity?: number\n  diffusion?: number\n  showVelocity?: boolean\n  showDensity?: boolean\n  addVelocity?: boolean\n  addDensity?: boolean\n  animate?: boolean\n  circle?: boolean\n  className?: string\n}\n\nexport function FluidDynamics({\n  width = 300,\n  height = 300,\n  iterations = 3,\n  strength = 100,\n  radius = 1,\n  viscosity = 0.0,\n  diffusion = 0.0,\n  showVelocity = false,\n  showDensity = true,\n  addVelocity = true,\n  addDensity = true,\n  animate = true,\n  circle = true,\n  className = \"\",\n}: FluidDynamicsProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const hiddenCanvasRef = useRef<HTMLCanvasElement>(null)\n  const animationRef = useRef<number | null>(null)\n  const stateRef = useRef<{\n    u: number[]\n    v: number[]\n    u_old: number[]\n    v_old: number[]\n    dens: number[]\n    dens_old: number[]\n    isAnimating: boolean\n    isHovering: boolean\n    lastX: number\n    lastY: number\n    time: number\n    red: number[]\n    grn: number[]\n    blu: number[]\n  } | null>(null)\n\n  const generateColorArrays = useCallback(() => {\n    const ncol = 500\n    const red = new Array(ncol)\n    const grn = new Array(ncol)\n    const blu = new Array(ncol)\n\n    // Generate heat map colors (black -> red -> yellow -> white)\n    for (let i = 0; i < ncol; i++) {\n      const t = i / (ncol - 1)\n\n      if (t < 0.25) {\n        // Black to red\n        red[i] = Math.floor(t * 4 * 255)\n        grn[i] = 0\n        blu[i] = 0\n      } else if (t < 0.5) {\n        // Red to yellow\n        red[i] = 255\n        grn[i] = Math.floor((t - 0.25) * 4 * 255)\n        blu[i] = 0\n      } else if (t < 0.75) {\n        // Yellow to white\n        red[i] = 255\n        grn[i] = 255\n        blu[i] = Math.floor((t - 0.5) * 4 * 255)\n      } else {\n        // White\n        red[i] = 255\n        grn[i] = 255\n        blu[i] = 255\n      }\n    }\n\n    return { red, grn, blu }\n  }, [])\n\n  const IX = useCallback((i: number, j: number, w: number) => {\n    return j * w + i\n  }, [])\n\n  const setBoundary = useCallback(\n    (b: number, x: number[], w: number, h: number) => {\n      for (let i = 1; i <= h; i++) {\n        x[IX(0, i, w)] = 0\n        x[IX(w + 1, i, w)] = 0\n        x[IX(i, 0, w)] = 0\n        x[IX(i, w + 1, w)] = 0\n      }\n\n      x[IX(0, 0, w)] = 0.5 * (x[IX(1, 0, w)] + x[IX(0, 1, w)])\n      x[IX(0, w + 1, w)] = 0.5 * (x[IX(1, w + 1, w)] + x[IX(0, h, w)])\n      x[IX(w + 1, 0, w)] = 0.5 * (x[IX(w, 0, w)] + x[IX(w + 1, 1, w)])\n      x[IX(w + 1, h + 1, w)] = 0.5 * (x[IX(w, h + 1, w)] + x[IX(w + 1, w, w)])\n    },\n    [IX]\n  )\n\n  const diffuse = useCallback(\n    (\n      b: number,\n      x: number[],\n      x0: number[],\n      diff: number,\n      dt: number,\n      iter: number,\n      w: number,\n      h: number\n    ) => {\n      const a = dt * diff * w * w\n\n      for (let k = 0; k < iter; k++) {\n        for (let i = 1; i <= w; i++) {\n          for (let j = 1; j <= h; j++) {\n            x[IX(i, j, w)] =\n              (x0[IX(i, j, w)] +\n                a *\n                  (x[IX(i - 1, j, w)] +\n                    x[IX(i + 1, j, w)] +\n                    x[IX(i, j - 1, w)] +\n                    x[IX(i, j + 1, w)])) /\n              (1 + 4 * a)\n          }\n        }\n        setBoundary(b, x, w, h)\n      }\n    },\n    [IX, setBoundary]\n  )\n\n  const advect = useCallback(\n    (\n      b: number,\n      d: number[],\n      d0: number[],\n      u: number[],\n      v: number[],\n      dt: number,\n      w: number,\n      h: number\n    ) => {\n      const dt0 = dt * w\n\n      for (let i = 1; i <= w; i++) {\n        for (let j = 1; j <= h; j++) {\n          let x = i - dt0 * u[IX(i, j, w)]\n          let y = j - dt0 * v[IX(i, j, w)]\n\n          if (x < 0.5) x = 0.5\n          if (x > w + 0.5) x = w + 0.5\n          const i0 = Math.floor(x)\n          const i1 = i0 + 1\n\n          if (y < 0.5) y = 0.5\n          if (y > h + 0.5) y = h + 0.5\n          const j0 = Math.floor(y)\n          const j1 = j0 + 1\n\n          const s1 = x - i0\n          const s0 = 1 - s1\n          const t1 = y - j0\n          const t0 = 1 - t1\n\n          d[IX(i, j, w)] =\n            s0 * (t0 * d0[IX(i0, j0, w)] + t1 * d0[IX(i0, j1, w)]) +\n            s1 * (t0 * d0[IX(i1, j0, w)] + t1 * d0[IX(i1, j1, w)])\n        }\n      }\n      setBoundary(b, d, w, h)\n    },\n    [IX, setBoundary]\n  )\n\n  const project = useCallback(\n    (\n      u: number[],\n      v: number[],\n      p: number[],\n      div: number[],\n      iter: number,\n      w: number,\n      h: number\n    ) => {\n      const h_val = 1.0 / w\n\n      for (let i = 1; i <= w; i++) {\n        for (let j = 1; j <= h; j++) {\n          div[IX(i, j, w)] =\n            -0.5 *\n            h_val *\n            (u[IX(i + 1, j, w)] -\n              u[IX(i - 1, j, w)] +\n              v[IX(i, j + 1, w)] -\n              v[IX(i, j - 1, w)])\n          p[IX(i, j, w)] = 0\n        }\n      }\n\n      setBoundary(0, div, w, h)\n      setBoundary(0, p, w, h)\n\n      for (let k = 0; k < iter; k++) {\n        for (let i = 1; i <= w; i++) {\n          for (let j = 1; j <= h; j++) {\n            p[IX(i, j, w)] =\n              (div[IX(i, j, w)] +\n                p[IX(i - 1, j, w)] +\n                p[IX(i + 1, j, w)] +\n                p[IX(i, j - 1, w)] +\n                p[IX(i, j + 1, w)]) /\n              4\n          }\n        }\n        setBoundary(0, p, w, h)\n      }\n\n      for (let i = 1; i <= w; i++) {\n        for (let j = 1; j <= h; j++) {\n          u[IX(i, j, w)] -=\n            (0.5 * (p[IX(i + 1, j, w)] - p[IX(i - 1, j, w)])) / h_val\n          v[IX(i, j, w)] -=\n            (0.5 * (p[IX(i, j + 1, w)] - p[IX(i, j - 1, w)])) / h_val\n        }\n      }\n      setBoundary(1, u, w, h)\n      setBoundary(2, v, w, h)\n    },\n    [IX, setBoundary]\n  )\n\n  const velStep = useCallback(\n    (\n      u: number[],\n      v: number[],\n      u0: number[],\n      v0: number[],\n      visc: number,\n      dt: number,\n      iter: number,\n      w: number,\n      h: number\n    ) => {\n      // Swap arrays\n      let tmp = u0\n      u0 = u\n      u = tmp\n      diffuse(1, u, u0, visc, dt, iter, w, h)\n      tmp = v0\n      v0 = v\n      v = tmp\n      diffuse(2, v, v0, visc, dt, iter, w, h)\n      project(u, v, u0, v0, iter, w, h)\n      tmp = u0\n      u0 = u\n      u = tmp\n      tmp = v0\n      v0 = v\n      v = tmp\n      advect(1, u, u0, u0, v0, dt, w, h)\n      advect(2, v, v0, u0, v0, dt, w, h)\n      project(u, v, u0, v0, iter, w, h)\n    },\n    [diffuse, advect, project]\n  )\n\n  const densStep = useCallback(\n    (\n      x: number[],\n      x0: number[],\n      u: number[],\n      v: number[],\n      diff: number,\n      dt: number,\n      iter: number,\n      w: number,\n      h: number\n    ) => {\n      let tmp = x0\n      x0 = x\n      x = tmp\n      diffuse(0, x, x0, diff, dt, iter, w, h)\n      tmp = x0\n      x0 = x\n      x = tmp\n      advect(0, x, x0, u, v, dt, w, h)\n    },\n    [diffuse, advect]\n  )\n\n  const addDensityAt = useCallback(\n    (x: number, y: number, amount: number, w: number, h: number) => {\n      if (!stateRef.current) return\n\n      for (let j = y - radius; j < y + radius; j++) {\n        for (let k = x - radius; k < x + radius; k++) {\n          if (j > radius && j < h - radius && k > radius && k < w - radius) {\n            stateRef.current.dens[j * w + k] += amount\n          }\n        }\n      }\n    },\n    [radius]\n  )\n\n  const addVelocityAt = useCallback(\n    (\n      x: number,\n      y: number,\n      amountX: number,\n      amountY: number,\n      w: number,\n      h: number\n    ) => {\n      if (!stateRef.current) return\n\n      for (let j = y - radius; j < y + radius; j++) {\n        for (let k = x - radius; k < x + radius; k++) {\n          if (j > radius && j < h - radius && k > radius && k < w - radius) {\n            stateRef.current.u[j * w + k] += amountX\n            stateRef.current.v[j * w + k] += amountY\n          }\n        }\n      }\n    },\n    [radius]\n  )\n\n  const drawTexture = useCallback(\n    (ctx: CanvasRenderingContext2D, w: number, h: number) => {\n      if (!stateRef.current) return\n\n      const imageData = ctx.getImageData(0, 0, w, h)\n      const data = imageData.data\n      const { u, v, dens, red, grn, blu } = stateRef.current\n\n      for (let x = 0; x < w; x++) {\n        for (let y = 0; y < h; y++) {\n          const i = y * w + x\n          let value = 0\n\n          if (showVelocity) {\n            value = Math.abs(Math.sqrt(u[i] * u[i] + v[i] * v[i]))\n          }\n          if (showDensity) {\n            value = dens[i]\n          }\n\n          const frac = Math.max(0.01, Math.min(0.99, value / 100))\n          const icol = Math.floor(frac * (red.length - 1))\n\n          const pxl = (x + y * w) * 4\n          data[pxl] = red[icol]\n          data[pxl + 1] = grn[icol]\n          data[pxl + 2] = blu[icol]\n          data[pxl + 3] = 255\n        }\n      }\n\n      ctx.putImageData(imageData, 0, 0)\n    },\n    [showVelocity, showDensity]\n  )\n\n  const getMousePos = useCallback(\n    (canvas: HTMLCanvasElement, e: MouseEvent | TouchEvent) => {\n      const rect = canvas.getBoundingClientRect()\n      const clientX = \"touches\" in e ? e.touches[0].clientX : e.clientX\n      const clientY = \"touches\" in e ? e.touches[0].clientY : e.clientY\n\n      const scaleX = width / canvas.width\n      const scaleY = height / canvas.height\n\n      return {\n        x: Math.round((clientX - rect.left) * scaleX),\n        y: Math.round((clientY - rect.top) * scaleY),\n      }\n    },\n    [width, height]\n  )\n\n  const handleInteraction = useCallback(\n    (x: number, y: number, prevX?: number, prevY?: number) => {\n      if (!stateRef.current) return\n\n      if (addDensity) {\n        addDensityAt(x, y, strength, width, height)\n      }\n\n      if (addVelocity && prevX !== undefined && prevY !== undefined) {\n        addVelocityAt(\n          x,\n          y,\n          strength * (x - prevX),\n          strength * (y - prevY),\n          width,\n          height\n        )\n      }\n    },\n    [\n      addDensity,\n      addVelocity,\n      addDensityAt,\n      addVelocityAt,\n      strength,\n      width,\n      height,\n    ]\n  )\n\n  const animate_loop = useCallback(() => {\n    if (!canvasRef.current || !hiddenCanvasRef.current || !stateRef.current)\n      return\n\n    const canvas = canvasRef.current\n    const hiddenCanvas = hiddenCanvasRef.current\n    const ctx = canvas.getContext(\"2d\", { alpha: true })\n    const hiddenCtx = hiddenCanvas.getContext(\"2d\", { alpha: true })\n\n    if (!ctx || !hiddenCtx) return\n\n    // Auto animation\n    if (animate && circle && stateRef.current.isAnimating) {\n      stateRef.current.time += 0.02\n      const x = Math.round(\n        width / 2 + (width / 4) * Math.cos(stateRef.current.time)\n      )\n      const y = Math.round(\n        height / 2 + (height / 4) * Math.sin(stateRef.current.time)\n      )\n\n      handleInteraction(x, y, stateRef.current.lastX, stateRef.current.lastY)\n      stateRef.current.lastX = x\n      stateRef.current.lastY = y\n    }\n\n    // Physics simulation\n    velStep(\n      stateRef.current.u,\n      stateRef.current.v,\n      stateRef.current.u_old,\n      stateRef.current.v_old,\n      viscosity,\n      0.0001,\n      iterations,\n      width,\n      height\n    )\n\n    densStep(\n      stateRef.current.dens,\n      stateRef.current.dens_old,\n      stateRef.current.u,\n      stateRef.current.v,\n      diffusion,\n      0.0001,\n      iterations,\n      width,\n      height\n    )\n\n    // Render\n    drawTexture(hiddenCtx, width, height)\n\n    // Scale to canvas size\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n    ctx.drawImage(hiddenCanvas, 0, 0, canvas.width, canvas.height)\n\n    animationRef.current = requestAnimationFrame(animate_loop)\n  }, [\n    animate,\n    circle,\n    width,\n    height,\n    viscosity,\n    diffusion,\n    iterations,\n    handleInteraction,\n    velStep,\n    densStep,\n    drawTexture,\n  ])\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n    const hiddenCanvas = hiddenCanvasRef.current\n    if (!canvas || !hiddenCanvas) return\n\n    // Initialize state\n    const size = (width + 2) * (height + 2)\n    const colors = generateColorArrays()\n\n    stateRef.current = {\n      u: new Array(size).fill(0),\n      v: new Array(size).fill(0),\n      u_old: new Array(size).fill(0),\n      v_old: new Array(size).fill(0),\n      dens: new Array(size).fill(0),\n      dens_old: new Array(size).fill(0),\n      isAnimating: true,\n      isHovering: false,\n      lastX: -1,\n      lastY: -1,\n      time: 0,\n      ...colors,\n    }\n\n    const updateCanvasSize = () => {\n      canvas.width = window.innerWidth\n      canvas.height = window.innerHeight\n      hiddenCanvas.width = width\n      hiddenCanvas.height = height\n    }\n\n    updateCanvasSize()\n    window.addEventListener(\"resize\", updateCanvasSize)\n\n    const handleMouseEnter = () => {\n      if (!stateRef.current) return\n      stateRef.current.isHovering = true\n      stateRef.current.isAnimating = false\n    }\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!stateRef.current || !stateRef.current.isHovering) return\n      const pos = getMousePos(canvas, e)\n      handleInteraction(\n        pos.x,\n        pos.y,\n        stateRef.current.lastX,\n        stateRef.current.lastY\n      )\n      stateRef.current.lastX = pos.x\n      stateRef.current.lastY = pos.y\n    }\n\n    const handleMouseLeave = () => {\n      if (!stateRef.current) return\n      stateRef.current.isHovering = false\n      stateRef.current.isAnimating = true\n      stateRef.current.lastX = -1\n      stateRef.current.lastY = -1\n    }\n\n    // Touch events for mobile\n    const handleTouchStart = (e: TouchEvent) => {\n      e.preventDefault()\n      if (!stateRef.current) return\n      stateRef.current.isAnimating = false\n      const pos = getMousePos(canvas, e)\n      handleInteraction(pos.x, pos.y)\n      stateRef.current.lastX = pos.x\n      stateRef.current.lastY = pos.y\n    }\n\n    const handleTouchMove = (e: TouchEvent) => {\n      e.preventDefault()\n      if (!stateRef.current) return\n      const pos = getMousePos(canvas, e)\n      handleInteraction(\n        pos.x,\n        pos.y,\n        stateRef.current.lastX,\n        stateRef.current.lastY\n      )\n      stateRef.current.lastX = pos.x\n      stateRef.current.lastY = pos.y\n    }\n\n    const handleTouchEnd = (e: TouchEvent) => {\n      e.preventDefault()\n      if (!stateRef.current) return\n      stateRef.current.isAnimating = true\n      stateRef.current.lastX = -1\n      stateRef.current.lastY = -1\n    }\n\n    canvas.addEventListener(\"mouseenter\", handleMouseEnter)\n    canvas.addEventListener(\"mousemove\", handleMouseMove)\n    canvas.addEventListener(\"mouseleave\", handleMouseLeave)\n    canvas.addEventListener(\"touchstart\", handleTouchStart)\n    canvas.addEventListener(\"touchmove\", handleTouchMove)\n    canvas.addEventListener(\"touchend\", handleTouchEnd)\n    canvas.addEventListener(\"touchcancel\", handleTouchEnd)\n\n    // Start animation\n    animate_loop()\n\n    return () => {\n      // Cleanup\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current)\n      }\n      window.removeEventListener(\"resize\", updateCanvasSize)\n      canvas.removeEventListener(\"mouseenter\", handleMouseEnter)\n      canvas.removeEventListener(\"mousemove\", handleMouseMove)\n      canvas.removeEventListener(\"mouseleave\", handleMouseLeave)\n      canvas.removeEventListener(\"touchstart\", handleTouchStart)\n      canvas.removeEventListener(\"touchmove\", handleTouchMove)\n      canvas.removeEventListener(\"touchend\", handleTouchEnd)\n      canvas.removeEventListener(\"touchcancel\", handleTouchEnd)\n    }\n  }, [\n    width,\n    height,\n    generateColorArrays,\n    getMousePos,\n    handleInteraction,\n    animate_loop,\n  ])\n\n  return (\n    <div\n      className={`absolute inset-0 h-full w-full overflow-hidden ${className}`}\n    >\n      <canvas\n        ref={canvasRef}\n        className=\"block h-full w-full\"\n        style={{\n          display: \"block\",\n          background: \"transparent\",\n        }}\n      />\n      <canvas ref={hiddenCanvasRef} style={{ display: \"none\" }} />\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    }
  ]
}