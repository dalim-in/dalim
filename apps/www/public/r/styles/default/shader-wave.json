{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "shader-wave",
  "type": "registry:ui",
  "files": [
    {
      "path": "registry/default/ui/backgrounds/shader-wave.tsx",
      "content": "/*\n  Single-file Wave component using @react-three/fiber and @react-three/drei.\n  - Transparent background\n  - Centered plane in scene\n  - All inline, no external CSS\n*/\n\n\"use client\"\n\nimport type React from \"react\"\nimport { Suspense, useRef, useState } from \"react\"\nimport { OrthographicCamera, shaderMaterial } from \"@react-three/drei\"\nimport { Canvas, extend, useFrame } from \"@react-three/fiber\"\nimport * as THREE from \"three\"\n\n// Wave shader material\nconst WaveMaterial = shaderMaterial(\n  {\n    time: 0,\n    resolution: new THREE.Vector2(1, 1),\n    pointer: new THREE.Vector2(0.0, 0.0),\n    tiles: 1.5,\n  },\n  /* glsl */ `\n    varying vec2 vUv;\n    void main() {\n      vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n      vec4 viewPosition = viewMatrix * modelPosition;\n      vec4 projectionPosition = projectionMatrix * viewPosition;\n      gl_Position = projectionPosition;\n      vUv = uv;\n    }\n  `,\n  /* glsl */ `\n    uniform float time;\n    uniform vec2 resolution;\n    uniform vec2 pointer;\n    uniform float tiles;\n    varying vec2 vUv;\n\n    vec3 palette(float t) {\n      vec3 a = vec3(0.5, 0.5, 0.5);\n      vec3 b = vec3(0.5, 0.5, 0.5);\n      vec3 c = vec3(1.0, 1.0, 1.0);\n      vec3 d = vec3(0.263, 0.416, 0.557);\n      return a + b * cos(6.28318 * (c * t + d));\n    }\n\n    void main() {\n  vec2 uv = vUv * 2.0 - 1.0;  // -1..1 centered coords\n  vec2 uv0 = uv;\n  vec3 finalColor = vec3(0.0);\n\n  uv = uv * tiles - pointer;\n\n  float d = length(uv) * exp(-length(uv0));\n  vec3 col = palette(length(uv0) + time * 0.4);\n  d = sin(d * 8.0 + time) / 8.0;\n  d = abs(d);\n  d = pow(0.02 / d, 2.0);\n  finalColor += col * d;\n\n  float alpha = clamp(length(finalColor), 0.0, 1.0);\n  gl_FragColor = vec4(finalColor, alpha);\n}\n\n  `\n)\n\nextend({ WaveMaterial })\n\nexport type WaveProps = {\n  width?: number\n  height?: number\n  speed?: number\n  tiles?: number\n  pointer?: { x: number; y: number }\n  disablePointerTracking?: boolean\n  dpr?: number | [number, number]\n  onPointerMove?: (e: React.PointerEvent<HTMLDivElement>) => void\n  className?: string\n  style?: React.CSSProperties\n}\n\nfunction WaveQuad({\n  speed = 1,\n  tiles = 1.5,\n  width = 600,\n  height = 400,\n  pointerOverride,\n  trackPointer = true,\n}: {\n  speed?: number\n  tiles?: number\n  width?: number\n  height?: number\n  pointerOverride?: { x: number; y: number }\n  trackPointer?: boolean\n}) {\n  const matRef = useRef<THREE.ShaderMaterial>(null)\n\n  useFrame((state, delta) => {\n    if (!matRef.current) return\n    matRef.current.uniforms.time.value += delta * speed\n    matRef.current.uniforms.resolution.value.set(\n      state.size.width,\n      state.size.height\n    )\n\n    if (pointerOverride) {\n      matRef.current.uniforms.pointer.value.set(\n        pointerOverride.x,\n        pointerOverride.y\n      )\n    } else if (trackPointer) {\n      matRef.current.uniforms.pointer.value.set(\n        state.pointer.x,\n        state.pointer.y\n      )\n    }\n\n    matRef.current.uniforms.tiles.value = tiles\n  })\n\n  return (\n    <group>\n      {/* Centered camera looking straight at origin */}\n      <OrthographicCamera makeDefault position={[0, 0, 10]} />\n      <mesh position={[0, 0, 0]}>\n        {/* Fixed-size plane in center */}\n        <planeGeometry args={[width, height]} />\n        {/* @ts-expect-error - intrinsic element added via extend */}\n        <waveMaterial ref={matRef} transparent />\n      </mesh>\n    </group>\n  )\n}\n\nexport function ShaderWave({\n  width = 1200,\n  height = 900,\n  speed = 1,\n  tiles = 1.5,\n  pointer: pointerOverride,\n  disablePointerTracking = false,\n  dpr = [1, 2],\n  onPointerMove,\n  className,\n  style,\n}: WaveProps) {\n  const [localPointer, setLocalPointer] = useState<{\n    x: number\n    y: number\n  } | null>(null)\n\n  return (\n    <div\n      className={className}\n      style={{\n        width,\n        height,\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        overflow: \"hidden\",\n        ...style,\n      }}\n      onPointerMove={(e) => {\n        if (!disablePointerTracking && !pointerOverride) {\n          const rect = (\n            e.currentTarget as HTMLDivElement\n          ).getBoundingClientRect()\n          const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1\n          const ny = -(((e.clientY - rect.top) / rect.height) * 2 - 1)\n          setLocalPointer({ x: nx, y: ny })\n        }\n        onPointerMove?.(e)\n      }}\n    >\n      <Canvas\n        dpr={dpr}\n        frameloop=\"always\"\n        gl={{ antialias: true, alpha: true }}\n        camera={{ position: [0, 0, 10] }}\n        style={{ background: \"transparent\" }}\n      >\n        <Suspense fallback={null}>\n          <WaveQuad\n            speed={speed}\n            tiles={tiles}\n            width={width}\n            height={height}\n            pointerOverride={pointerOverride ?? localPointer ?? undefined}\n            trackPointer={!disablePointerTracking && !pointerOverride}\n          />\n        </Suspense>\n      </Canvas>\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    }
  ]
}