{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "render-canvas",
  "type": "registry:ui",
  "files": [
    {
      "path": "registry/default/ui/backgrounds/render-canvas.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-var */\n/* eslint-disable @typescript-eslint/no-unused-expressions */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-nocheck\n\n\"use client\"\n\nimport { useEffect, useRef } from \"react\"\n\nimport { cn } from \"@/registry/default/lib/utils\"\n\ninterface RenderCanvasProps {\n  // Animation configuration\n  trails?: number\n  size?: number\n  friction?: number\n  dampening?: number\n  tension?: number\n\n  // Visual properties\n  lineWidth?: number\n  colorHue?: number\n  colorSaturation?: number\n  colorLightness?: number\n  opacity?: number\n\n  // Wave animation for color cycling\n  enableColorCycle?: boolean\n  colorCycleSpeed?: number\n  colorCycleAmplitude?: number\n\n  // Canvas dimensions\n  width?: number\n  height?: number\n\n  // Styling\n  className?: string\n}\n\nexport function RenderCanvas({\n  trails = 80,\n  size = 50,\n  friction = 0.5,\n  dampening = 0.025,\n  tension = 0.99,\n  lineWidth = 10,\n  colorHue = 285,\n  colorSaturation = 100,\n  colorLightness = 50,\n  opacity = 0.025,\n  enableColorCycle = true,\n  colorCycleSpeed = 0.0015,\n  colorCycleAmplitude = 85,\n  width = 700,\n  height = 650,\n  className = \"\",\n}: RenderCanvasProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const animationRef = useRef<{\n    ctx:\n      | (CanvasRenderingContext2D & { running?: boolean; frame?: number })\n      | null\n    cleanup: () => void\n  }>({ ctx: null, cleanup: () => {} })\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D & {\n      running?: boolean\n      frame?: number\n    }\n    if (!ctx) return\n\n    ctx.running = true\n    ctx.frame = 1\n    animationRef.current.ctx = ctx\n\n    // Wave function for color cycling\n    function WaveFunction(config: any) {\n      this.phase = config.phase || 0\n      this.offset = config.offset || 0\n      this.frequency = config.frequency || 0.001\n      this.amplitude = config.amplitude || 1\n    }\n\n    WaveFunction.prototype.update = function () {\n      this.phase += this.frequency\n      return this.offset + Math.sin(this.phase) * this.amplitude\n    }\n\n    // Node class for trail points\n    function Node() {\n      this.x = 0\n      this.y = 0\n      this.vy = 0\n      this.vx = 0\n    }\n\n    // Line class for trail effects\n    function Line(config: any) {\n      this.spring = config.spring + 0.1 * Math.random() - 0.05\n      this.friction = friction + 0.01 * Math.random() - 0.005\n      this.nodes = []\n      for (let i = 0; i < size; i++) {\n        const node = new Node()\n        node.x = pos.x\n        node.y = pos.y\n        this.nodes.push(node)\n      }\n    }\n\n    Line.prototype.update = function () {\n      let spring = this.spring\n      let node = this.nodes[0]\n      node.vx += (pos.x - node.x) * spring\n      node.vy += (pos.y - node.y) * spring\n\n      for (let i = 0; i < this.nodes.length; i++) {\n        node = this.nodes[i]\n        if (i > 0) {\n          const prevNode = this.nodes[i - 1]\n          node.vx += (prevNode.x - node.x) * spring\n          node.vy += (prevNode.y - node.y) * spring\n          node.vx += prevNode.vx * dampening\n          node.vy += prevNode.vy * dampening\n        }\n        node.vx *= this.friction\n        node.vy *= this.friction\n        node.x += node.vx\n        node.y += node.vy\n        spring *= tension\n      }\n    }\n\n    Line.prototype.draw = function () {\n      if (this.nodes.length < 2) return\n\n      let x = this.nodes[0].x\n      let y = this.nodes[0].y\n      ctx.beginPath()\n      ctx.moveTo(x, y)\n\n      for (let i = 1; i < this.nodes.length - 2; i++) {\n        const node = this.nodes[i]\n        const nextNode = this.nodes[i + 1]\n        x = 0.5 * (node.x + nextNode.x)\n        y = 0.5 * (node.y + nextNode.y)\n        ctx.quadraticCurveTo(node.x, node.y, x, y)\n      }\n\n      if (this.nodes.length >= 2) {\n        const secondLast = this.nodes[this.nodes.length - 2]\n        const last = this.nodes[this.nodes.length - 1]\n        ctx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y)\n      }\n\n      ctx.stroke()\n      ctx.closePath()\n    }\n\n    // Initialize variables\n    let colorWave: any = null\n    const pos = { x: canvas.width / 2, y: canvas.height / 2 } // ✅ start centered\n    let lines: any[] = []\n\n    if (enableColorCycle) {\n      colorWave = new WaveFunction({\n        phase: Math.random() * 2 * Math.PI,\n        amplitude: colorCycleAmplitude,\n        frequency: colorCycleSpeed,\n        offset: colorHue,\n      })\n    }\n\n    function createLines() {\n      lines = []\n      for (let i = 0; i < trails; i++) {\n        lines.push(new Line({ spring: 0.45 + (i / trails) * 0.025 }))\n      }\n    }\n\n    // ✅ Fix cursor offset using bounding rect\n    function handleMouseMove(e: MouseEvent | TouchEvent) {\n      const rect = canvas.getBoundingClientRect()\n      if (\"touches\" in e && e.touches) {\n        pos.x = e.touches[0].clientX - rect.left\n        pos.y = e.touches[0].clientY - rect.top\n      } else {\n        const mouseEvent = e as MouseEvent\n        pos.x = mouseEvent.clientX - rect.left\n        pos.y = mouseEvent.clientY - rect.top\n      }\n      e.preventDefault()\n    }\n\n    function handleTouchStart(e: TouchEvent) {\n      if (e.touches.length === 1) {\n        const rect = canvas.getBoundingClientRect()\n        pos.x = e.touches[0].clientX - rect.left\n        pos.y = e.touches[0].clientY - rect.top\n      }\n    }\n\n    function render() {\n      if (!ctx.running) return\n\n      ctx.globalCompositeOperation = \"source-over\"\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n      ctx.globalCompositeOperation = \"lighter\"\n\n      if (enableColorCycle && colorWave) {\n        ctx.strokeStyle = `hsla(${Math.round(colorWave.update())},${colorSaturation}%,${colorLightness}%,${opacity})`\n      } else {\n        ctx.strokeStyle = `hsla(${colorHue},${colorSaturation}%,${colorLightness}%,${opacity})`\n      }\n\n      ctx.lineWidth = lineWidth\n\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i]\n        line.update()\n        line.draw()\n      }\n\n      ctx.frame++\n      requestAnimationFrame(render)\n    }\n\n    function resizeCanvas() {\n      const rect = canvas.getBoundingClientRect()\n      canvas.width = width || rect.width\n      canvas.height = height || rect.height\n    }\n\n    function initializeAnimation(e: MouseEvent | TouchEvent) {\n      document.removeEventListener(\"mousemove\", initializeAnimation)\n      document.removeEventListener(\"touchstart\", initializeAnimation)\n\n      document.addEventListener(\"mousemove\", handleMouseMove)\n      document.addEventListener(\"touchmove\", handleMouseMove)\n      document.addEventListener(\"touchstart\", handleTouchStart)\n\n      handleMouseMove(e)\n      createLines()\n      render()\n    }\n\n    // Set up event listeners\n    document.addEventListener(\"mousemove\", initializeAnimation)\n    document.addEventListener(\"touchstart\", initializeAnimation)\n    window.addEventListener(\"resize\", resizeCanvas)\n\n    const handleFocus = () => {\n      if (!ctx.running) {\n        ctx.running = true\n        render()\n      }\n    }\n\n    const handleBlur = () => {\n      ctx.running = false\n    }\n\n    window.addEventListener(\"focus\", handleFocus)\n    window.addEventListener(\"blur\", handleBlur)\n\n    resizeCanvas()\n\n    // Cleanup function\n    animationRef.current.cleanup = () => {\n      ctx.running = false\n      document.removeEventListener(\"mousemove\", initializeAnimation)\n      document.removeEventListener(\"touchstart\", initializeAnimation)\n      document.removeEventListener(\"mousemove\", handleMouseMove)\n      document.removeEventListener(\"touchmove\", handleMouseMove)\n      document.removeEventListener(\"touchstart\", handleTouchStart)\n      window.removeEventListener(\"resize\", resizeCanvas)\n      window.removeEventListener(\"focus\", handleFocus)\n      window.removeEventListener(\"blur\", handleBlur)\n    }\n\n    return () => {\n      animationRef.current.cleanup()\n    }\n  }, [\n    trails,\n    size,\n    friction,\n    dampening,\n    tension,\n    lineWidth,\n    colorHue,\n    colorSaturation,\n    colorLightness,\n    opacity,\n    enableColorCycle,\n    colorCycleSpeed,\n    colorCycleAmplitude,\n    width,\n    height,\n  ])\n\n  return (\n    <div\n      className={cn(\n        \"relative flex flex-col items-center justify-center overflow-hidden\",\n        className\n      )}\n      style={{ height, width }} // ✅ dynamic sizing\n    >\n      <canvas\n        ref={canvasRef}\n        id=\"canvas\"\n        className=\"absolute inset-0 h-full w-full cursor-default\"\n      />\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    }
  ]
}